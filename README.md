# pwc-general-prj
사용자가 관심있는 기업을 등록하고, 조회 · 수정 · 삭제할 수 있는 CRUD 기반 웹

**✅ 필수 과제 수행 완료**   
**✅ 선택 과제 수행 완료**

## 트러블슈팅 및 회고
### [필수과제]
### Next.js 성능 최적화를 위한 고민
#### 1. 관심기업 목록 페이지의 렌더링 전략 (SSR 선택 이유)
관심기업 목록은 로그인한 사용자에게만 의미 있는 개인화 데이터로, SEO보다는 **초기 로딩 경험(Initial Rendering UX)** 이 더 중요하다고 판단했습니다.

CSR로 구현할 경우, 페이지가 먼저 렌더링된 뒤 useEffect 또는 클라이언트 요청으로 테이블이 비어 있다가 나중에 채워지는 “깜빡임” 경험이 발생할 수 있습니다. 과제에서는 이를 피하고, **첫 진입 시점부터 데이터가 채워진 테이블을 제공하기 위해** Next.js 서버 컴포넌트 기반 SSR을 선택했습니다.

즉, 초기 관심기업 조회는 서버에서 미리 패칭하여
**사용자가 진입하는 순간 이미 완성된 화면을 볼 수 있도록 설계**했습니다.

---

#### 2. SSR 환경에서의 캐싱 전략 (cache: "no-store" + router.refresh)
SSR 렌더링 이후 관심기업 등록/삭제와 같은 사용자 조작이 발생하면 UI와 서버 데이터가 즉시 동기화되어야 합니다.

이를 위해 다음과 같은 조합을 사용했습니다:
* fetch(cache: "no-store") → SSR 시점마다 항상 최신 데이터를 가져오도록 설정
* router.refresh() → 클라이언트에서 데이터 조작 성공 시 서버 컴포넌트를 재요청하여 즉시 최신 데이터로 리렌더링
두 기능을 함께 사용함으로써 **DB 변경 → 즉시 SSR 데이터 갱신 → UI 반영**이 끊김 없이 이루어지도록 만들었습니다.

---

#### 3. 서버/클라이언트 역할 분리 및 React Query 기반의 상호작용 최적화
초기 관심기업 목록 조회는 **서버 컴포넌트(Home)에서 SSR로 처리**하고, 실제 화면 렌더링과 사용자 상호작용(등록/삭제/메모 수정 등)은 **클라이언트 컴포넌트(HomeClient)로 분리**했습니다.

HomeClient 내부에서는 React Query를 활용하여
* 관심기업 등록/삭제와 같은 **데이터 조작 시 로딩/에러 상태 관리**
* 요청 성공 후 router.refresh()를 통한 **SSR 데이터와의 동기화**
* 필요한 경우 클라이언트 캐싱을 활용한 **불필요한 중복 요청 최소화**
등의 기능을 제공해 사용자 경험을 최적화했습니다.

이렇게 서버 컴포넌트와 클라이언트 컴포넌트를 명확히 역할 분리함으로써, **초기 로딩 단계에서는 SSR로 빠르고 완성된 첫 화면 제공함으로써 UX를 최적화**하고, **이후 사용자 상호작용 단계에서는 React Query의 장점을 살려 로딩/에러/상태 관리와 부분적 캐싱을 최적화**하는 구조를 목표로 설계했습니다.

실제 서비스 환경에서는 이 페이지를 CSR + React Query 기반으로 구성하고 클라이언트 캐싱/Optimistic UI까지 고려하는 것도 좋은 선택이 될 수 있다고 생각합니다. 하지만 이번 과제에서는 **Next.js의 서버 데이터 페칭 특성과 초기 로딩 UX를 극대화하는 방향**에 좀 더 초점을 맞춰 SSR 방식을 선택했습니다.

---

#### 웹 접근성을 위한 테이블 UI 시맨틱 마크업에 대한 고민
초기에는 웹접근성과 시맨틱 구조를 지키기 위해 단일 table안에 thead+tbody를 유지한 채, tbody만 스크롤되는 구조를 만들려고 했습니다. 가상요소 마스킹, absolute 레이어, z-index 등 다양한 기법을 시도했지만, **macOS 오버레이 스크롤바 특성상 헤더 영역을 완전히 가리는 것이 현실적으로 불가능**하다는 한계가 있었습니다.

대안으로 피그마 시안을 맞추기 위해 **테이블을 헤더/바디 두 개로 분리해 tbody 영역에만 스크롤을 적용하는 방식**도 구현해보았습니다. 하지만 이 페이지는 복잡한 리포트형 테이블이 아니라 **개인 위시리스트 성격의 목록**이며, API에서 이미 **한 페이지당 11개씩 제공하는 페이지네이션 구조**였기 때문에 스크롤 UI 자체가 UX적으로 꼭 필요한 요소가 아니라는 결론에 도달했습니다.

최종적으로 스크롤바는 과감히 제거하고, **단일 테이블 구조 + sticky header + 페이지네이션 중심 UI**로 단순화하여 시맨틱 마크업·접근성·디자인 요구사항 간의 균형을 맞추는 방향을 선택했습니다.

---

### [선택과제]
> ✅ DART Open API의 corpCode.xml을 JSON으로 변환해 로컬 데이터로 활용하고, 기업 고유번호를 기반으로 **Next.js API Routes에서 필요한 재무제표 데이터만 가공해 프론트에 전달하는 핵심 기능은 모두 구현했습니다.**  
> ✅ 다만 피그마 시안에 제시된 **완성형 재무상태표 UI 전체는 시간 제약으로 인해 모두 구현하지는 못했습니다.** (핵심 조회 로직·API 매핑·뷰어 렌더링은 완료)

#### 재무제표 API 선택 이유 (단일회사 전체 재무제표 API)
피그마 시안에서는 검색한 **단일 기업의 재무제표**를 조회하고,
동시에 **재무제표 유형(OFS: 재무제표 / CFS: 연결재무제표)** 을 필수로 선택하도록 되어 있습니다.

DART Open API의 여러 엔드포인트 중 아래 3개의 단일회사 관련 API를 비교한 결과,
- 단일회사 주요계정 (fnlttSinglAcnt)
- 단일회사 주요 재무지표 (fnlttSinglIndx)
- 단일회사 전체 재무제표 (fnlttSinglAcntAll) 
UI 요구사항에서 재무제표 유형 선택은 **fs_div 파라미터와 1:1로 연결**되는데,
이는 “단일회사 전체 재무제표 API”에서만 지원됩니다.

결론적으로 **UI 요구사항과 API 스펙을 모두 충족하는 가장 효율적인 방식**이 단일회사 전체 재무제표 API(fnlttSinglAcntAll)를 활용하는 것이었고, 이에 따라 본 재무제표 뷰어는 해당 API를 기반으로 구현했습니다.

---

### Zustand를 도입하지 않은 이유
이번 과제에서는
* 관심기업 CRUD 페이지: **SSR + React Query** 기반으로 서버 상태를 렌더링 직전 서버에서 패칭하고, 이후 등록/수정/삭제 시 router.refresh()를 사용해 서버 상태를 즉시 동기화.
* 재무제표 뷰어 페이지: **CSR + React Query** 기반으로 동작하며, 검색 폼 → API 요청 → 결과 렌더링까지 모든 로직이 **단일 페이지 내부**에서만 처리되는 구조.
이라는 비교적 단순한 구조이기 때문에, 별도의 전역 상태 관리 라이브러리(Zustand)를 도입하지 않았습니다.

로딩/에러/데이터 캐싱은 이미 **React Query가 서버 상태와 함께 일관되게 관리**해 주고 있고, 각 페이지의 UI 상태 또한 컴포넌트 트리 상에서 **props 드릴링이 심하지 않은 수준**이라 전역 스토어로 끌어올릴 필요성이 크지 않았습니다.

Zustand는 여러 페이지에서 공유해야 하는 복잡한 UI 상태나 다단계 플로우(예: 로그인/회원가입, 장바구니, 마이페이지 탭 등)가 있을 때 유용하지만, 이번 과제처럼 **서로 독립적인 두 기능(관심기업 목록, 재무제표 조회)** 만을 다루는 상황에서 새로운 의존성을 추가하는 것은 오히려 **오버엔지니어링**이라고 판단했습니다.

필요하다면 추후 기능 확장(실제 로그인, 사용자별 설정/필터 공유 등) 단계에서 Zustand를 도입하는 것이 더 적절하다고 보고, 이번 구현에서는 **React Query + 로컬 상태 조합만으로 충분히 해결**하는 방향을 선택했습니다.

---

### 🤖 AI 활용 범위
- 선택과제 진행 중 DART Open API 구조 및 활용법(corpCode.xml → JSON 변환, fnlttSinglAcntAll API 사용 방식) 을 이해하는 데 참고용으로 사용했습니다.
- README의 트러블슈팅 및 기술 선택 근거는 문장 흐름과 가독성을 높이기 위한 표현 정리 수준에서 첨삭 도움을 받았습니다.
- TypeScript와 같은 정적 타입 언어에 아직 완전히 익숙하지 않은 부분은 AI의 설명을 참고하여 타입 정의 및 타입 오류 해결 과정을 보완했습니다.

---

### ⏳ 시간상 구현하지 못한 부분
[필수과제]
- 최상위 라우트에서 발생하는 공통 에러를 처리하는 error.tsx 페이지는 시간 관계상 구현하지 못했습니다.
- 필수과제(관심기업 생성)와 선택과제(기업명 검색) 모두에서 활용되는 Searchable Dropdown을 공통 컴포넌트로 분리하지 못한 점이 아쉽습니다. 각 페이지 요구사항에 집중하면서 UI/UX 구현을 우선하다 보니 공통화 작업까지는 진행하지 못했습니다.

[선택과제]
- 사업연도/보고서명/재무제표 유형 선택 UI는 시안처럼 커스텀 <div> 기반 셀렉트 박스로 구현하지 못하고, 기본 <select> 요소로 대체했습니다.  
- 재무제표 뷰어의 마크업·스타일링(특히 재무상태표 형태)은 시안 수준으로 구현하지 못하고, 핵심 데이터 조회·매핑 기능 위주로 구현했습니다.  

